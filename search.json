[
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Lecture #\nDate\nTopic\n\n\n\n\n1\n3 Jan\nIntroduction and Logistics [Slides]\n\n\nNone\n4 Jan\nPre-requisites quiz released\n\n\n2\n5 Jan\nConvention, Metrics, Classification, Regression [Slides]\n\n\n3\n10 Jan\nDecision Trees - 1[Slides][Notebook]\n\n\n4\n12 Jan\nDecision Trees - 2[Slides][Notebook]\n\n\n5\n17 Jan\nBias and Variance[Slides][Notebook on Python utils][Notebook on Grid Search]\n\n\nNone\n18 Jan\nQuiz 1\n\n\n6\n19 Jan\nBias, Variance 2, Cross Validation[Slides]\n\n\n7\n24 Jan\nEnsemble Methods[Slides]\n\n\n8\n31 Jan\nEnsemble Methods[Slides], Weighted samples in decision trees[Slides], Maths for ML-1 [Slides] [Notebook-1] [Notebook 2], [Streamlit app] Linear Regression [Slides]\n\n\n9\n2 Feb\nLinear Regression [Slides], Contour Plots [Slides], Geometric View of Linear Regression [Slides]\n\n\n10\n9 Feb\nLinear Regression II [Slides]\n\n\n11\n14 Feb\nGradient Descent [Slides], Taylor’s Series, Notebook on Taylor’s series, Reference on relationship between Taylor’s series and GD, Reference 2\n\n\n12\n16 Feb\nGradient Descent [Slides] Notebook\n\n\n13\n21 Feb\nGradient Descent continued, [Ridge Regression], [Streamlit demo], [Additional reading on SGD being an unbiased estimator]\n\n\n14\n23 Feb\nRidge regression, LASSO, [Interactive article on Optimization algorithms]\n\n\n15\n28 Feb\nLogistic regression [Slides], [Notebook] (best run locally to render interactive visualisations)\n\n\n16\n2 Mar\nLogistic regression [Slides]\n\n\n17\n14 Mar\nLogistic regression [Slides]\n\n\n18\n16 Mar\nMLP [Slides]\n\n\n19\n21 Mar\nMLP [Slides], Notebook\n\n\n20\n28 Mar\nMLP [Slides]\n\n\n21\n30 Mar\nNext work prediction [Slides], Notebook\n\n\n22\n4 Apr\nConvolutional Neural Networks [Slides], 1d CNN slides, Notebook 1, Notebook 2, Notebook 3, Equivariance v/s Invariance, Reference1, Reference2, Notebook\n\n\n23\n6 Apr\nAutograd [Slides], Notebook on Autodiff, Reference on chain rule Naive Bayes [Slides]\n\n\n24\n11 Apr\nNaive Bayes [Slides], KNN [Slides]\n\n\n25\n13 Apr\nKNN, Parametric v/s Non-Parametric, Movie Recommendation\n\n\n26\n18 Apr\nCurse of Dimensionality, Segment Anything demo, Unsupervised learning, Image segmentation, Image completion, KMeans Viz 1, Viz 2, PCA reference\n\n\n27\n20 Apr\nConstrained Optimization (self study), Support Vector Machines -1\n\n\n28\n23 Apr\nSupport Vector Machines\n\n\n29\n25 Apr\nSupport Vector Machines (Soft Margin)"
  },
  {
    "objectID": "grading.html",
    "href": "grading.html",
    "title": "Grading Policy",
    "section": "",
    "text": "Quizzes: 48%\n\n16% each\nBest 3 out of 4\nIf you miss a single quiz for any reason, there will be no makeups\n\n\n\n\nAssignments: 44%\n\n4 or 5 assignments\nDone in groups of 5\nAtleast one question per assignment will be a project-like question\nVariable weight (e.g. some assignments would be 10%, some 12%, etc.)\nSome assignments would involve:\n\nMaking pull requests to public repositories\nWriting Hugging Face Spaces like demos\n\n\n\n\n\nAttendance: 8%\n\n&lt;= 3 absences: 8%\n4 or 5 absences: 7%\n6 or 7 absences: 6%\n8 or 9 absences: 4%\n10 or 11 absences: 2%\n12 or more absences: 0%"
  },
  {
    "objectID": "exams/q3.html",
    "href": "exams/q3.html",
    "title": "Quiz 3 (27 Feb)",
    "section": "",
    "text": "Total Time: 1 hour 15 mins AND Total Marks: 10\n\n\nMany evaluation metrics decompose over the training examples. For example, the loss function for linear regression (proportional to mean squared error) is given as: \\[L(\\theta) = \\frac{1}{2N}\\sum_{i=1}^N (y_i - \\sum_{d=1}^D \\theta_d x_i^d)^2\\] where \\(N\\) is the number of training examples, \\(x_i\\) is the \\(i^{th}\\) training example and \\(y_i\\) is the corresponding label. Mention any evaluation metric/loss function in machine learning that does not decompose over the training examples. [1 mark]\nWe saw the figure showing SGD convergence. \n\n\n2A) Prove that SGD is an unbiased estimator. [1 mark]\n2B) It seems that the SGD algorithm is not converging to the global minimum. Why do you think this is the case? [1 mark]\n2C). Why is it generally a good idea to use a small learning rate for SGD? [1 mark]\n2D) It seems that while the SGD algorithm is not converging, but it seems to be very quickly moving close to the global minimum. Why is SGD good initially when the loss is high? To help you answer this question, we pose a series of questions. Consider a simplification of linear regression. Our data is 1d. Our model is \\(y=\\theta x\\). Consider a dataset of \\(N\\) examples. Obtain the closed form solution for \\(\\theta\\) in terms of the scalars \\(x_i\\) and \\(y_i\\) for \\(i=1, \\cdots, N\\). [1 marks]\n2E) Consider \\(N=3\\) and a datset of the form \\(x_1=1, x_2=2, x_3=3, y_1=1, y_2=2.2, y_3=2.8\\). Plot the approximate contour plot of the loss function \\(L(\\theta)\\) for \\(\\theta \\in [-1, 3]\\). [1 marks].\n2F) Plot the loss v/s parameters (\\(\\theta\\)) corresponding to the loss for each training input. [1 marks]\n2G) Now, answer why SGD works initially, when the loss is high. [1 marks]\n\n\nIn an above question, we proved that the SGD estimator is an unbiased estimator. We have also previously discussed that we typically have a bias-variance tradeoff in our models. In the recent assignment question, we have plotted the bias and variance for different complexity trees. In this question, you have to derive the mean squared error in terms of three terms: bias, variance and irreducible noise.\n\n\nLet us assume our data is generated from a `true’ function \\(f(x)\\) and we have some additional zero mean normally distributed noise \\(\\epsilon \\sim \\mathcal{N}(0, \\sigma^2)\\).\n\\[y = f(x) + \\epsilon\\]\nWe can use some model such as a decision tree or linear regression to approximate \\(f(x)\\). We now consider a single training example \\((x_0, y_0)\\). We can define the mean squared error as:\n\\[MSE = \\mathbb{E}[(y_0 - \\hat{f}(x_0)^2)]\\]\nwhere \\(y\\) is the true label and \\(\\hat{f}(x_0)\\) is the predicted label. The expectation is over all possible training sets that could have been generated.\nTo keep the notation simple, we refer \\(f(x_0)\\) as \\(f\\) and \\(\\hat{f}(x_0)\\) as \\(\\hat{f}\\). Thus, we can write \\[MSE = \\mathbb{E}[(f - \\hat{f})^2]\\] We also define the bias as the difference between the true function and the predicted function, evaluated at the training example: \\[bias = \\mathbb{E}[\\hat{f}] - f\\] or, \\[bias = \\overline{f} - f\\] where \\(\\overline{f}\\) is the average/expectation of the predicted function over all possible training sets.\nWe define the variance as: \\[variance = VAR(\\hat{f})\\] or,\n\\[variance = \\mathbb{E}[(\\hat{f} - \\overline{f})^2]\\]\nWe define irreducible noise as the variance of the noise term \\(\\epsilon\\):\n\\[irreducible = VAR(\\epsilon)\\] or,\n\\[irreducible = \\sigma^2\\]\nUsing the above definitions, show that the mean squared error can be written as:\n\\[MSE = bias^2 + variance + irreducible\\]\n[2 marks]"
  },
  {
    "objectID": "exams/q5.html",
    "href": "exams/q5.html",
    "title": "Quiz 5 (6 April)",
    "section": "",
    "text": "Total Time: 1 hour 15 mins AND Total Marks: 10\n\n\nAssume that we want to design a neural network with two layers by composing two linear layers. That is, the output of the first layer becomes the input of the second layer. Why would such a naive composition not work? Or, in other words show that without using a non-linear activation, we get a linear model. You can show this for a single datapoint \\((1 X D)\\) instead of showing this for \\(N\\) datapoints.(1 mark)\nFor this task, we are trying to use a neural network to predict a non-negative real number. However, in general, the output of a neural network is not constrained to be non-negative. Thus, we try to solve this problem by learning \\(f(\\hat{y})\\) as the output of the neural network, and we then apply \\(f^{-1}(f(\\hat{y}))\\) to finally get a \\(\\hat{y}\\) which is guaranteed to be non-negative? Can you give an example of what \\(f\\) and thus its inverse can be? Please note: you are not allowed to use ReLU activation. Further, we want our function f and its inverse to be continuous and differentiable everywhere.(1 mark)\nDraw a simple perceptron with two inputs and one output for the binary AND problem. Remember that the simple perceptron works on binary input and produces binary outputs. Show that your model works for all four inputs ((1, 1), (1, 0), (0, 0) and (0, 1))(1 mark)\nShow that the following network using ReLu activation works for the XOR problem. (1 mark; 0.25 marks for each of the four possible inputs (0,0), (0,1), (1,0), (1,1)) \nAssume we are solving the 3-class classification problem. We have two models (M1 and M2) from which we get two different output probabilities: \\(\\hat{y}_1 = (0.2, 0.7, 0.1)\\), \\(\\hat{y}_1 = (0.2, 0.5, 0.3)\\). The true class is \\(y = 0\\). Which of M1 or M2 has a higher cross-entropy losses? (1 mark)\nWe have the following code\n\nclass M_A(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fc1 = nn.Linear(784, 64)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, 10)\n        \n    def forward(self, x):\n        z1 = self.fc1(x)\n        a1 = F.relu(z1)\n        z2 = self.fc2(a1)\n        a2 = F.relu(z2)\n        z3 = self.fc3(a2) # logits\n        return z3\n\nclass M_B(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.fc1 = nn.Linear(784, 64)\n        self.fc2 = nn.Linear(64, 32)\n        self.fc3 = nn.Linear(32, 10)\n        \n    def forward(self, x):\n        z1 = self.fc1(x)\n        z2 = self.fc2(z1)\n        z3 = self.fc3(z2) \n        return z3\nBoth models have the same number of parameters despite some differences. Explain? (1 mark)\n\nLet us learn a model to predict the next character given a context of k previous characters. We have a total v characters in our vocabulary (e.g., a, b, …, z, _) Let us use an embedding size of e, i.e. each character in our vocabulary is represented as e length vector. Now, let us use a simple MLP with one hidden layer with h hidden units. What is the total number of parameters in this model? (1 mark)\nAssume the above setup in Q7. We observe that our embedding has “overfitted”, i.e. the embedding vectors are very far from the origin. Can you suggest an additional loss term that can help us to bring the embeddings closer to the origin and thus act as a regularisation? (1 mark)\nAs discussed in the lecture, chatGPT like systems are similar to the above model. But, we know that chatGPT can produce many different outputs for the same input. Let us use a simplification and consider next character prediction problem. Our model outputs a probability distribution over the next character. However, if we just pick up the most probable class/character, we should always get the same output given the same input. But, how do chatGPT like systems generate different outputs? (1 mark)\nAssume a MLP input of 4 dimensions, 2 real outputs, first hidden layers of 3 units, second hidden layer of 2 units, and a final output layer of 2 units. What is the total number of parameters in this model? (1 mark)"
  },
  {
    "objectID": "exams/assignment-5.html",
    "href": "exams/assignment-5.html",
    "title": "Assignment 5",
    "section": "",
    "text": "General instructions\n\nFeel free to use any framework of your choice: PyTorch, JAX (+Flax/Equinox), Tensorflow (+Keras)\nWe are not providing any code template. However, it is recommended you adhere to high code quality standards.\nFeel free to make use of ChatGPT, CoPilot, etc. like tools. Cite where you used them. However, you should still be able to explain your code during the viva. Also, you need to be careful with the hallucinations of these tools!\nAs before, this assignment is in a group of two students. You do not need to submit the assignment but can show your private repo to the TA during the viva.\n\n\n\nIn this question, you have to compare the performance on a binary classification task of the following models:\n\nVGG (1 block)\nVGG (3 blocks)\nVGG (3 blocks) with data augmentation\nTransfer learning using VGG16 or VGG19\n\nRefer this article You do not need to write your own code. You can reuse the code from the post. Or, you could roll out your own implemenation. Either way, you should be able to explain your code during the viva.\nYou need to create the dataset on your own based on your first names. For instance if the first name of the team members are: Siya and Raghav, they can choose a dataset of their liking based on any names, place, animal or thing. As examples:\n\nSeoul v/s Riyadh\nSnake v/s Rat\nSquirrel v/s Rabbit\nSambhar v/s Roti\n\nYou can refer to resource 1 or resource 2 or plainly download 100 images of both classes (total 200 images). Of these 100 images of each class, we will use 80 for training and 20 for testing. You get 1 mark for dataset creation [1 mark]\nCreate a table with models as rows and the following columns [2 marks (0.5 marks for each model)]\n\nTraining time\nTraining loss\nTraining accuracy\nTesting accuracy\nNumber of model parameters\n\nWe will now be using Tensorboard for visualizing network performance. You are suggested to refer to:\n\nPyTorch + Tensorboard\nTensorflow + Tensorboard\n\nUse Tensorboard to log the following and present screenshots/images [1 mark]\nScalars\n\nTraining loss v/s iterations (and not epochs)\nTraining accuracy v/s iterations (and not epochs)\nTesting accuracy v/s iterations (and not epochs)\n\nImages\n\nShow all images from the test set and their predictions\n\nNow you have to present various insights. For instance, you should discuss the following: [2 marks (0.5 marks for each question)]\n\nAre the results as expected? Why or why not?\nDoes data augmentation help? Why or why not?\nDoes it matter how many epochs you fine tune the model? Why or why not?\nAre there any particular images that the model is confused about? Why or why not?\n\nNow, create a MLP model with comparable number of parameters as VGG16 and compare your performance with the other models in the table. You can choose the distribution of number of neurons and number of layers. What can you conclude? [1 mark]"
  },
  {
    "objectID": "quizzes.html",
    "href": "quizzes.html",
    "title": "Quizzes",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nJan 5, 2023\n\n\nPrerequsite test\n\n\n\n\n\n\n\nJan 18, 2023\n\n\nQuiz 1 (18 Jan)\n\n\n\n\n\n\n\nFeb 8, 2023\n\n\nQuiz 2 (8 Feb)\n\n\n\n\n\n\n\nFeb 27, 2023\n\n\nQuiz 3 (27 Feb)\n\n\n\n\n\n\n\nMar 25, 2023\n\n\nQuiz 4 (25 March)\n\n\n\n\n\n\n\nMar 26, 2023\n\n\nAssignment 5\n\n\n\n\n\n\n\nApr 6, 2023\n\n\nQuiz 5 (6 April)\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ES 335 Machine Learning",
    "section": "",
    "text": "Summary\n\nInstructor: Nipun Batra (nipun.batra@iitgn.ac.in)\nTeaching Assistants: Rishiraj Adhikary, Ayush Shrivastava\nCourse Timings:\n\nLectures: Monday, Wednesday 8:30 AM to 10 AM in 10/103\nTutorials: Friday: 1130 to 1 PM in 10/103\n\nSlack Invite\n\n\n\nPre-requisites:\n\nGood experience in Python programming\nProbability\nLinear Algebra\n\nCourse preparation: Students are encouraged to study some of the following to refresh their understanding of some of the prerequisities before the course formally begins.\n\nFirst four chapters of the Python Data Science handbook\nSome material on Linear Algebra\nKhan academy course on Stats and Probability\n\n\n\nReference textbooks:\n\nGareth James, Daniela Witten, Trevor Hastie and Robert Tibshirani. An Introduction to Statistical Learning with Applications in R\nChristopher Bishop. Pattern Recognition and Machine Learning. Springer, 2006.[Freely available online]\nFriedman J, Hastie T, Tibshirani R. The elements of statistical learning. New York, NY, USA:: Springer series in statistics; 2001.[Freely available online]\nDuda RO, Hart PE, Stork DG. Pattern classification. John Wiley & Sons; 2012 Nov 9.\nMitchell TM. Machine learning. 1997. Burr Ridge, IL: McGraw Hill. 1997;45(37):870-7.\nMurphy, K. Machine Learning: A Probabilistic Perspective. MIT Press\nGoodfellow I, Bengio Y, Courville A, Bengio Y. Deep learning. Cambridge: MIT press; 2016 Nov 18.[Freely available online]\n\n\n\nSome other ML courses\n\nNPTEL course by Balaram Ravindran\nCMU course by Tom Mitchell and Maria-Florina Balcan\nCoursera ML course by Andrew Ng\nFAST.ai course on ML\nPractical deep learning for coders by FAST.ai\nCourse by Alex Ihler, UCI"
  },
  {
    "objectID": "exams/q2.html",
    "href": "exams/q2.html",
    "title": "Quiz 2 (8 Feb)",
    "section": "",
    "text": "Total Time: 1 hour 15 mins AND Total Marks: 10\n\n\nIn bootstrap sampling, we sample with replacement from the original dataset. Let us assume that the original dataset of size \\(N\\) has all distinct elements. As an example if \\(N=8\\), we may have the dataset as \\(\\{1, 2,3, 4, 5, 6, 7, 8\\}\\). A bootstrap sample (or round) is also of size \\(N\\) and can contain some elements more than once. For example, a bootstrap sample may be \\(\\{8, 8, 3, 4, 5, 1, 8, 5\\}\\). The unique elements in this sample are: \\(\\{1, 3, 4, 5, 8\\}\\). This sample has 5 unique elements. Show that on average the number of unique elements in a bootstrap sample is \\(63.2\\%\\) of \\(N\\). [1.5 marks]\nWe studied the ADABoost classification algorithm for binary classification. We wrote the final prediction as: \\(\\mathrm{SIGN}(\\sum{\\alpha_i}h_i(x))\\) where \\(\\alpha_i\\) is the weight of the classifier \\(h_i\\) and \\(h_i(x)\\) is the prediction of the classifier \\(h_i\\) on the input \\(x\\). We also noted that each prediction \\(h_i(x)\\) is either \\(+1\\) or \\(-1\\).\nExtend ADABoost to multi-class classification where we have \\(K\\) classes and each classifier predicts one of the \\(K\\) classes (a number from \\(\\{1 \\cdots K\\}\\)). As an example, if we have \\(m=4\\) members in the ensemble, we may have something like \\(h_1(x) = 1\\), \\(h_2(x) = 2\\), \\(h_3(x) = 3\\) and \\(h_4(x) = 2\\). Now, write the formula for prediction for multi-class classification using the ensemble of classifiers, i.e. for any input \\(x\\), which class amongst \\(\\{1 \\cdots K\\}\\)) will be predicted as a function of \\(\\alpha_i\\)s and \\(h_i(x)\\)? Note: do not use the concept of one-vs-one or one-vs-all here. [2 marks]\nWhich hyperparameter can you vary to control the bias-variance tradeoff (or complexity) for decision trees? Draw the bias variance tradeoff curve for decision trees using this hyperparameter. Explain your answer. [1.5 mark]\nThe normal equation for linear regression is given as: \\(\\hat{\\theta} = (X^TX)^{-1}X^Ty\\). Instead of computing the normal equation directly, let us use the SVD decomposition of X. We decompose X as \\(X = U\\Sigma V^T\\).\n\n\nRewrite the normal equation using the reduced SVD decomposition of X, that is write \\(\\hat{\\theta}\\) in terms of \\(U\\), \\(\\Sigma\\) and \\(V\\) and \\(y\\).\n\n\nFor this question, let us assume that \\(X\\) is of size \\(n \\times m\\) and \\(y\\) is of size \\(n \\times 1\\). Let us also assume that the number of features \\(m\\) is significantly less than the number of samples \\(n\\).\n\n\nOnce you have written \\(\\hat{\\theta}\\) in terms of \\(U\\), \\(\\Sigma\\) and \\(V\\) and \\(y\\), find the time complexity of computing \\(\\hat{\\theta}\\) using the reduced form of SVD decomposition of \\(X\\). [4 marks]\n\n\nWe provide some background on the SVD decomposition of a matrix \\(X\\) below: The reduced form of SVD decomposition of \\(X\\) is given as \\(X = U\\Sigma V^T\\) where \\(U\\) is of size \\(n \\times m\\), \\(\\Sigma\\) is of size \\(m \\times m\\) and \\(V\\) is of size \\(m \\times m\\). The columns of \\(U\\) are called the left singular vectors of \\(X\\) and the columns of \\(V\\) are called the right singular vectors of \\(X\\). The singular matrix \\(\\Sigma\\) is a diagonal matrix: it has zeros everywhere except on the diagonal. The diagonal elements of \\(\\Sigma\\) are the singular values of \\(X\\). The singular values of \\(X\\) are always non-negative and are arranged in decreasing order. The singular values of \\(X\\) are also called the eigenvalues of \\(X^TX\\).\n\n\nFurther, for reduced SVD, \\(U^TU = I\\) and \\(V^TV = I\\) and \\(VV^T = I\\) where \\(I\\) is the identity matrix.\n\n\nWe also provide some background on the time complexity of matrix multiplication below: Let \\(A\\) be of size \\(n \\times m\\), \\(B\\) be of size \\(m \\times p\\) and \\(C\\) be of size \\(n \\times p\\). The time complexity of computing \\(C = AB\\) is \\(O(nmp)\\). Further, the time complexity of inverse of a \\(n \\times n\\) matrix \\(A\\) is \\(O(n^3)\\). The time complexity of computing SVD of the above \\(n \\times m\\) matrix \\(X\\) is \\(O(nm^2)\\). You should factor this time complexity in your answer for computing \\(\\hat{\\theta}\\).\n\n\nBONUS: Solve the above problem (computing \\(\\hat{\\theta}\\) and its time complexity) with the full version of SVD, what changes will you need to make? The full version of SVD is given as \\(X = U\\Sigma V^T\\) where \\(U\\) is of size \\(n \\times n\\), \\(\\Sigma\\) is of size \\(n \\times m\\) and \\(V\\) is of size \\(m \\times m\\). \\(U\\) and \\(V\\) are orthogonal matrices. [2 marks]\n\n\nLet us assume \\(K\\) members in an ensemble. For simplicity let us assume that each member in the ensemble has the same probability of error \\(p&lt;0.5\\). We saw in the class that the probability of error (given by the binomial expansion) reduces as we increase the number of members in the ensemble. But, empirically adding more members in an ensemble may not always reduce the error. Why? [1 mark]"
  },
  {
    "objectID": "exams/prereq.html",
    "href": "exams/prereq.html",
    "title": "Prerequsite test",
    "section": "",
    "text": "Instructions\n\nThis test is open book, open internet, open notes. You can use any resources you want to solve the problems.\nYou should be typing your answers in a Jupyter notebook.\nThe submission would be a link to a public GitHub repository containing the notebook. Fill this form to submit your solution.\nA random subset of students may have a viva post the exam. The viva would be based on the notebook and the solutions you have provided.\nThe test is open till 6th January 2022 9 PM. You can submit your solutions anytime before that.\nThis problem has to be solved individually. You cannot collaborate with anyone else.\nThe code should be written using Python.\nSome questions may require you to answer in text. You can use markdown cells to write your answers. Some questions may require you to write code. You can use code cells to write your code. Some questions may require you to write mathematical expressions. You can use LaTeX to write your expressions. You can write such LaTeX expressions in markdown cells.\nFor any other questions, please ask on the General channel on Slack.\n\n\n\n\nQuestions\n\nHow many multiplications and additions do you need to perform a matrix multiplication between a (n, k) and (k, m) matrix? Explain.\nWrite Python code to multiply the above two matrices. Solve using list of lists and then use numpy. Compare the timing of both solutions. Which one is faster? Why?\nFinding the highest element in a list requires one pass of the array. Finding the second highest element requires 2 passes of the the array. Using this method, what is the time complexity of finding the median of the array? Can you suggest a better method? Can you implement both these methods in Python and compare against numpy.median routine in terms of time?\nWhat is the gradient of the following function with respect to x and y? \\[\nx^2y+y^3\\sin(x)\n\\]\nUse JAX to confirm the gradient evaluated by your method matches the analytical solution corresponding to a few random values of x and y\nUse sympy to confirm that you obtain the same gradient analytically.\nCreate a Python nested dictionary to represent hierarchical information. We want to store record of students and their marks. Something like:\n\n2022\n\nBranch 1\n\nRoll Number: 1, Name: N, Marks:\n\nMaths: 100, English: 70 …\n\n\nBranch 2\n\n2023\n\nBranch 1\nBranch 2\n\n2024\n\nBranch 1\nBranch 2\n\n2025\n\nBranch 1\nBranch 2\n\n\nStore the same information using Python classes. We have an overall database which is a list of year objects. Each year contains a list of branches. Each branch contains a list of students. Each student has some properties like name, roll number and has marks in some subjects.\nUsing matplotlib plot the following functions on the domain: x = 0.5 to 100.0 in steps of 0.5.\n\n\\(y = x\\)\n\\(y = x^2\\)\n\\(y = \\frac{x^3}{100}\\)\n\\(y = \\sin(x)\\)\n\\(y = \\frac{\\sin(x)}{x}\\)\n\\(y = \\log(x)\\)\n\\(y = e^x\\)\n\nUsing numpy generate a matrix of size 20X5 containing random numbers drawn uniformly from the range of 1 to 2. Using Pandas create a dataframe out of this matrix. Name the columns of the dataframe as “a”, “b”, “c”, “d”, “e”. Find the column with the highest standard deviation. Find the row with the lowest mean.\nAdd a new column to the dataframe called “f” which is the sum of the columns “a”, “b”, “c”, “d”, “e”. Create another column called “g”. The value in the column “g” should be “LT8” if the value in the column “f” is less than 8 and “GT8” otherwise. Find the number of rows in the dataframe where the value in the column “g” is “LT8”. Find the standard deviation of the column “f” for the rows where the value in the column “g” is “LT8” and “GT8” respectively.\nWrite a small piece of code to explain broadcasting in numpy.\nWrite a function to compute the argmin of a numpy array. The function should take a numpy array as input and return the index of the minimum element. You can use the np.argmin function to verify your solution."
  },
  {
    "objectID": "exams/q4.html",
    "href": "exams/q4.html",
    "title": "Quiz 4 (25 March)",
    "section": "",
    "text": "Total Time: 1 hour 15 mins AND Total Marks: 10\n\n\n\nConsider the figure above, where we fit the model \\(p(y=1 \\mid \\mathbf{x}, \\bm{{\\theta}})=\\sigma\\left(\\theta_0+\\theta_1 x_1+\\theta_2 x_2\\right)\\) by maximum likelihood, i.e., we minimize \\(J_a({\\theta})=-\\ell\\left(\\bm{{\\theta}}, \\mathcal{D}_{\\text {train }}\\right)\\) where \\(\\ell\\left(\\bm{{\\theta}}, \\mathcal{D}_{\\text {train }}\\right)\\) is the log likelihood on the training set. In the questions below, when multiple decision boundaries are possible, you should choose the one which minimizes the number of classification errors on the training dataset.\n\n\nSketch a decision boundary for the model. How many classification errors does your method make? (1 mark)\n\n\nNow, we regularize only the \\(\\theta_0\\) parameter, i.e., we minimize: \\(J_b({\\theta})=-\\ell\\left(\\bm{{\\theta}}, \\mathcal{D}_{\\text {train }}\\right)+\\lambda \\theta_0^2\\). Suppose \\(\\lambda\\) is a very large number, so we regularize \\(\\theta_0\\) all the way to 0, but all other parameters are unregularized. Sketch a possible decision boundary. How many classification errors does your method make? (1 mark)\n\n\nRepeat part (b), but we now instead regularize the \\(\\theta_1\\) parameter. (1 mark)\n\n\nRepeat part (b), but we now instead regularize the \\(\\theta_2\\) parameter. (1 mark)\n\n\nProve that softmax is equivalent to sigmoid when there are only two classes. (1 mark)\n\\(y = \\sigma(z)\\), where \\(\\sigma\\) is the sigmoid function. We also know that \\(z = f(a)\\). Find \\(\\dfrac{\\partial y}{\\partial a}\\). (1 mark)\nLet us consider a \\(K\\)-class logistic regression problem. For some example, \\(x\\), we get our outputs before the application of softmax as: \\(z_1=x^T\\theta_1\\), \\(\\cdots , z_k=x^T\\theta_k\\), \\(\\cdots ,z_K=x^T\\theta_K\\). We denote the vector of outputs as \\(\\vec{z} = \\left[\\begin{array}{@{}c@{}}  z_{1} \\\\  z_{2} \\\\  \\vdots \\\\  z_{K}  \\end{array} \\right]\\)\n\nWe will try to now use the cross entropy loss function to train our model. One of the terms in the cross entropy loss function is: \\(\\log\\left(\\frac{e^{z_k}}{\\sum_{j=1}^K e^{z_j}}\\right)\\) which we refer to as \\(\\mathrm{LOGSOFTMAX}(z_k, \\vec{z})\\). However, we find that \\(\\mathrm{LOGSOFTMAX}(z_k, \\vec{z})\\) cannot be computed directly for several cases. When \\(z_k\\) is a large number (e.g. 5000), a computer is unable to compute \\(e^{z_k}\\) as an overflow occurs (\\(e^{z_k}\\) = inf). When \\(z_k\\) is a large negative number (e.g. -5000), \\(e^{z_k}\\) = 0.0.\n\n\nWhat problem occurs in computing \\(\\mathrm{LOGSOFTMAX}(z_k, \\vec{z})\\) when all elements of \\(\\vec{z}\\) are large (in magnitude) negative numbers (e.g. all \\(z_i &lt; -6000\\))? (1 mark)\n\n\nModify the \\(\\mathrm{LOGSOFTMAX}(z_k, \\vec{z})\\) expression using some trick so that we are able to compute it for any \\(z_k\\) and \\(\\vec{z}\\). You need to show the steps/simplifications you make. Show that this trick solves both the above problems (overflow and the problem you find in part (a) of this question) (2 marks)\n\n\n\nWe use a new type of coin for coin toss experiments. For this coin, the probability of heads goes down exponentially with the draw. Assuming the probaility of heads for the first draw (\\(i=1\\)) is \\(\\theta\\) and for the \\(i\\)th draw is \\(\\theta_i = \\dfrac{\\theta}{2^{i-1}}\\). What is the maximum likelihood estimate for \\(\\theta\\) for obtaining the draws as: T, H, H. Assume that each draw is independent of the others. Ofcourse, the identical assumption can not be made. (1 mark)"
  },
  {
    "objectID": "exams/q1.html",
    "href": "exams/q1.html",
    "title": "Quiz 1 (18 Jan)",
    "section": "",
    "text": "Instructions\n\nTotal Time: 30 mins\n\n\n\nRemember the entropy discussion we had in the lecture. We saw that for the Tennis example, the maximum entropy is 1.0. What is the maximum entropy an Imagenet classification problem, where we have 1024 classes? [1 mark]\nGiven the following dataset, what attribute/feature would the decision tree algorithm choose to split the data on for the first iteration? Why? [1 mark]\n\n\n\n\n\n\n\n\n\n\n\nSample #\nTomato radius\nTomato weight\nTomato color\nTomato quality\n\n\n\n\n1\n1\n1\n1\nGood\n\n\n2\n1\n1\n2\nGood\n\n\n3\n1\n2\n1\nBad\n\n\n4\n1\n2\n2\nBad\n\n\n5\n2\n1\n1\nGood\n\n\n6\n2\n2\n2\nGood\n\n\n\n\nIn the lectures we saw that np.std(x) and pd.Series(x).std() are different. Why? [1 mark]\nQuoting Wikipedia:\n\n\nPruning is a data compression technique in machine learning and search algorithms that reduces the size of decision trees by removing sections of the tree that are non-critical and redundant to classify instances. Pruning reduces the complexity of the final classifier, and hence improves predictive accuracy by the reduction of overfitting.\n\n\nPre-pruning procedures prevent a complete induction of the training set by replacing a stop () criterion in the induction algorithm (e.g. max. Tree depth or information gain (Attr)&gt; minGain). Pre-pruning methods are do not induce an entire set, but rather trees remain small from the start.\n\nCreate a decision tree for the following classification problem. Explain why the pre-pruning using information gain approach can be limiting? [2 marks]\n\n\n\n\\(x_1\\)\n\\(x_2\\)\n\\(y\\)\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\nVisualize the decision tree for the following regression problem, where the ground truth is the function \\(y = x + 2\\). Use \\(x = \\{1, 2, \\cdots 4\\}\\) as the training dataset. Also visualize the learnt function [2 marks]\nCreate an example ground truth and prediction where the mean absolute error is 100 and mean error is 0. [0.5 marks]\nCreate one confusion matrix for 100 total examples where the precision is 0.8, recall is 0.5. [1 mark]\nShow visualisation of 1d regression problem for continuous inputs showing a good fit, a high bias and a high variance fit. [1.5 mark]"
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "FAQ",
    "section": "",
    "text": "Prerequisites\n\nWhat are the course prerequisites?\n\nThe course has no “formal” prerequisites like all courses at IITGn. However, it is assumed that you have a basic understanding of:\n\nprogramming (Python), and data structures (ES242 equivalent)\nprobability and statistics\nlinear algebra\ncalculus\n\n\nHow can I prepare for the prerequisite exam?\n\nYour UG course material should be sufficient to prepare for the exam.\nYou may additionally refer to the “prerequisite” reading section on the course homepage.\n\nWhat happens if I do not clear the prerequisite exam?\n\nYou will not be allowed to take the course.\n\nWhat do you mean by “clear” the exam?\n\nLike all courses at IITGn, the instructor will decide the cut-off for the exam. You will have to score above the cut-off to clear the exam. No cut-off will be revealed to the students apriori.\n\n\n\n\n\nQuizzes\n\nWhat happens if I miss a quiz due to any reason?\n\nThe quiz will be marked as 0.\nThe provision of best 6 out of 8 quizzes is designed keeping in mind such scenarios.\n\nWill the quizzes and end-semester exam be open book? Will I be allowed to carry notes?\n\nNo, the exams and quizzes will be closed book. You are not permitted to carry notes.\n\nHow soon can I expect to receive my answer sheets back?\n\nYou should expect to receive answer sheets back in 4-5 working days.\n\nIs there an end-semester exam or mid-semester exam?\n\nNo, there is no end-semester exam or mid-semester exam. However, some of the quizzes may be held in the exam slot. In total we will have 8 equal weightage quizzes. The best 6 out of them will be considered for the final grade.\n\nWill the quizzes be MCQs or subjective?\n\nThe quizzes may contain both the MCQs and subjective questions.\n\n\n\n\n\nAssignments\n\nWhat happens if I miss an assignment due to any reason?\n\nThere will no extensions for assignments.\n\nI have a doubt in the assignment. Whom should I write to?\n\nAsk on the slack General channel. If you don’t get a response within 2 days, write to the course instructor.\n\nI do not know Python. Can I code assignments in some other language?\n\nUnfortunately, no. You have to stick to Python.\n\nHow will you evaluate the assignment?\n\nThe assignments would be followed by a viva. The TAs would first check the code and compare against the submission. Any change from the submitted code is not allowed and any instance of the same would culminate in a warning. The TAs would run the code and ask a few questions. About 75% of these questions would be based on the assignment in question and about 25% would be based on the theory behind the concepts covered in the assignment.\nThe grade breakup would be: i) code runs correctly and solves the problem [50% marks]; ii) questions based on the assignment and student understanding of code [25% marks]; iii) code quality [12.5% marks]; iv) questions based on the theory behind the concepts covered in the assignments [12.5% marks]\n\nIs the assignment individual or group?\n\nThe assignment is TBA. In case of group, all team members get the same grade for the assignment.\n\n\n\n\n\nAttendance\n\nAttendance policy\n\nAttendance is not mandatory, but highly encouraged. Marks often correlated with attendance.\n\n\n\n\n\nProjects\n\nIs there a project component in the course?\n\nNo. There is no project component in the course.\n\n\n\n\n\nBonus\n\nCan I choose a PR of my choice.\n\nYes, you can choose a PR of your choice from a list of PRs decided by the teaching staff. The teaching staff hold the right to decide whether a PR is suitable or not."
  }
]